// Cardio.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include "iostream"
#include "math.h"
#include <stdlib.h>
#include <stdio.h>
using namespace std;

//создаём функцию numboccur, которая ищет количество повторений ppp_unique[i] в ppp
int numboccur(double *ppp, double *pppUnique, int k)
{
	int amountRep = 0; //количество повторений. Rep - replay(повтор)
	for (int i = 0; i < sizeof(pppUnique); i++){
		for (int j = 0; j < sizeof(pppUnique); j++){
			if (ppp[i] == pppUnique[j]){
				amountRep++;
			}
		}
	}

	return amountRep;
}

double sign(double number)
{
	if (number < 0) {
		number = -1;
	}
	else {
		number = 1;
	}
	return number;
}

double heaviside(double number)
{
	if (number < 0) {
		number = 0;
	}
	else {
		number = 1;
	}
	return number;
}

/*
создаём процедуру
NNN_faz:=proc(B,NN,truefalse) local i, ii, y, v, ppp, lambda, s, j, n, ppp_unique, rvn; global t, yy, N;
*/

void faz(double *yy, double *t, int nn, double b, bool truefalse)	//в nn передаём значение int n = sizeof(rowdim) - 1;
{
	double rvn[100];		//размер полупроизвольный (сколько получится, но зависит от параметров)
	double y[100];
	double v[100];
	double lam[100];	//lambda
	double ppp[100];		// массив из троек элементов (пара элементов и количество его повторений)
	double pppUnique[100];
	double n[100];		//массив количеств повторений
	int ii, i, s, j;
	int iiStart, iStart, sStart, jStart;
	double aaa = abs(y[i + 1] - y[i]);
	double bbb = abs(v[i + 1] - v[i]);

	//создаём повторки чтобы потом вернуть начальные значения
	double rvnCopy[sizeof(rvn)];
	double yCopy[sizeof(y)];
	double vCopy[sizeof(v)];
	double lamCopy[sizeof(lam)];
	double nCopy[sizeof(n)];
	int iCopy, sCopy, jCopy;


	// копипастим чтобы запомнить

	for (int i = 0; i < sizeof(rvn); i++) {
		rvnCopy[i] = rvn[i];
	}
	for (int i = 0; i < sizeof(y); i++) {
		yCopy[i] = y[i];
	}
	for (int i = 0; i < sizeof(v); i++) {
		vCopy[i] = v[i];
	}
	for (int i = 0; i < sizeof(lam); i++) {
		lamCopy[i] = lam[i];
	}
	for (int i = 0; i < sizeof(n); i++) {
		nCopy[i] = n[i];
	}

	iCopy = i;
	sCopy = s;
	jCopy = j;

	//закончили копипаст


	if (truefalse != true && truefalse != false) {
		ii = -1;
		s = 0;
		for (i = 0; i < nn - 2; i++) {
			y[i] = round(b*yy[i]);
			y[i + 1] = (b*yy[i + 1]);
			v[i] = round((b*(yy[i + 1] - yy[i])) / ((t[i + 1] - t[i])));
			v[i + 1] = round(b*(yy[i + 2] - yy[i + 1]) / (t[i + 2] - t[i + 1]));
			if (aaa > bbb) {	//lam[i] = max(aaa, bbb);
				lam[i] = aaa;
			}
			else {
				lam[i] = bbb;
			}
			if (lam[i] != 0) {
				for (s = 0; s < lam[i] - 1; i++) {
					if (aaa > bbb) {
						ii++;
						ppp[0] = y[i] + sign(y[i + 1] - y[i])*s - heaviside(y[i] - y[i + 1]);
						ppp[1] = v[i] + trunc((v[i + 1] - v[i])*s / lam[i]) - heaviside(v[i] - v[i + 1]);
					}
					if (aaa <= bbb) {
						ii++;
						ppp[0] = y[i] + sign(y[i + 1] - y[i])*s - heaviside(y[i] - y[i + 1]);
						ppp[1] = v[i] + trunc((v[i + 1] - v[i])*s / lam[i]) - heaviside(v[i] - v[i + 1]);
					}
				}

			}
			else {
				ii++;
				ppp[0] = y[i];
				ppp[1] = v[i];
			}

			//возвращаем начальное значение
			for (int i = 0; i < sizeof(y); i++) {
				y[i] = yCopy[i];
			}
			for (int i = 0; i < sizeof(v); i++) {
				v[i] = vCopy[i];
			}
			for (int i = 0; i < sizeof(lam); i++) {
				lam[i] = lamCopy[i];
			}

		}

		i = iCopy;	//возвращаем начальное значение
		s = sCopy;	//возвращаем начальное значение
	}
	else {
		ii = 0;
		for (i = 0; i < nn - 2; i++) {
			if (has[T_sna, t[i]] == truefalse) {		// if has(T_sna,t[i])=truefalse then???
				y[i] = round(b*yy[i]);
				y[i + 1] = round(b*yy[i + 1]);
				v[i] = round(b*(yy[i + 1] - yy[i]) / (t[i + 1] - t[i]));
				v[i + 1] = round(b*(yy[i + 2] - yy[i + 1]) / (t[i + 2] - t[i + 1]));
				if (aaa > bbb) {	//lam[i] = max(aaa, bbb);
					lam[i] = aaa;
				}
				else {
					lam[i] = bbb;
				}
				if (lam[i] != 0) {
					for (s = 0; s < lam[i] - 1; i++) {
						if (aaa > bbb) {
							ii++;
							ppp[0] = y[i] + sign(y[i + 1] - y[i])*s - heaviside(y[i] - y[i + 1]);
							ppp[1] = v[i] + trunc((v[i + 1] - v[i])*s / lam[i]) - heaviside(v[i] - v[i + 1]);
						}
						if (aaa <= bbb) {
							ii++;
							ppp[0] = y[i] + sign(y[i + 1] - y[i])*s - heaviside(y[i] - y[i + 1]);
							ppp[1] = v[i] + trunc((v[i + 1] - v[i])*s / lam[i]) - heaviside(v[i] - v[i + 1]);
						}
					}

				}
				else {
					ii++;
					ppp[0] = y[i];
					ppp[1] = v[i];
				}
				//возвращаем начальное значение
				for (int i = 0; i < sizeof(y); i++) {
					y[i] = yCopy[i];
				}
				for (int i = 0; i < sizeof(v); i++) {
					v[i] = vCopy[i];
				}
				for (int i = 0; i < sizeof(lam); i++) {
					lam[i] = lamCopy[i];
				}
			}
			s = sCopy;
			j = jCopy;
			for (int i = 0; i < sizeof(n); i++) {
				n[i] = nCopy[i];
			}
			for (int i = 0; i < sizeof(rvn); i++) {
				rvn[i] = rvnCopy[i];
			}
		}

		/* Что здесь происходит
		for i from 1 to nops(ppp_unique) do
		n[i]: = numboccur(ppp, [ppp_unique[i]]) :
		rvn : = [op(rvn), [ppp_unique[i][1] / B, ppp_unique[i][2] / B, n[i]]] :
		end do :
		*/

		for (i = 0; i < sizeof(pppUnique); i++) {
			n[i] = numboccur(ppp, pppUnique, i);	//заполняем массив цифрами - количество повторений pppUnique в ppp

			// Ещё раз что такое rvn, зачем он и что в себе хранит, как его заполнять в данной части кода?

		}
	}
}


int main()
{
	double t[100];
	double y[100];
	double v[100];
	double yy[100];
	double rowdim[100];				//N1 - strings
	double coldim[100];				//N2 - colons
	double somethingImportant;		//incorrect name
	double tSleep[100];				//T_sna
	int n = sizeof(rowdim)-1;
	int nInitial = 0;				//N_nach
	int nFinal = n;					//N_konech
	int j = 0;
	int i = 0;
	int k = 0;
	double max = 0;
	double a = 13;					//hours of day
	double b = 8;					//hours of night
	int gapSleep[2];
	gapSleep[0] = (int)(a * 3600);
	gapSleep[1] = (int)(gapSleep[0] + b * 3600);

	if (sizeof(coldim)) {
		t[0] = 0;
		for (i = 0; i < nInitial + 1; i++) {
			t[0] = t[0] + rowdim[i] / 1000;
		}
		y[0] = 60 / rowdim[nInitial + 1] / 1000;
		for (i = nInitial + 1; i < nFinal; i++) {
			t[i - nInitial] = t[i - nInitial - 1] + rowdim[i + 1] / 1000;
			y[i - nInitial] = 60 / (rowdim[i + 1] / 1000);
		}
	}
	else {
		for (int i = nInitial; i < nFinal; i++) {
			t[i - nInitial] = rowdim[i + 1];
			y[i - nInitial] = coldim[i + 1];
		}
	}
	for (i = 0; i < n - 1; i++) {
		somethingImportant = abs((y[i + 1] - y[i]) / (t[i + 1] - t[i]));
		if (somethingImportant > max) max = somethingImportant;
	}
	while (max >= 100) {
		for (i = 0; i < n - 1; i++) {
			if (abs(y[i]) < 200 && somethingImportant < 100) {
				t[j] = t[i];
				y[j] = y[i];
				j++;
			}
		}
		n = j - 1;
	}
	n = sizeof(rowdim)-1;
	/*
	yt:=[seq([t[i],y[i]],i=0..N)]:
	t[0]:=t[0];
	t[N]:=t[N];
	*/
	for (j = 1; j < sizeof(gapSleep); i++) { //nops(gapSleep) from Maple
		for (i = 0; i < n; i++) {
			if (t[i] >= gapSleep[0] && t[i] <= gapSleep[1]) {
				k++;
				tSleep[k] = t[i];
			}
		}
	}
	for (i = 0; i < n; i++) {
		yy[i] = y[i];
	}


	return 0;
}
